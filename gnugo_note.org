#+STARTUP: align indent
#+LATEX_COMPILER: xelatex
#+LATEX_HEADER: \usepackage[UTF8, heading = false, scheme = plain]{ctex}
#+OPTIONS: tex:t
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{caption}
#+LATEX_HEADER: \usepackage{fancyvrb}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage[a4paper,left=2cm,right=2cm,top=1.8cm,bottom=1.8cm]{geometry}
#+LATEX_HEADER: \renewcommand*{\ttdefault}{qcr}


#+TITLE: GNU Go 文檔節譯
#+AUTHOR: 龔存
#+EMAIL: gcdevelop@163.com

* Worms and Dragons

在考慮走子之前，GNU Go 收集一些信息放入一些數組中。其中兩個數組，被稱為 *worm*
和 *dragon* ，將會在本章討論。其他內容將會在 [[eyes_and_halfeyes][Eyes and HalfEyes]] 中討論。

這些信息旨在幫助評估各組棋子的連接性，眼位形狀，逃生可能性以及死活狀態。

之後由 =genmove()= 調用的例程將可以訪問這些信息。本文試圖解釋這個初步分析的原理
和算法，它由 ='dragon.c'= 中的兩個例程 =make_worm()= 和 =make_dragon()= 來執行。

/Worm/ 是棋盤上最大的一組相同顏色的棋子，它們沿水平線或垂直線相連，我們經常可
以稱之為串而不是蠕蟲。

/Dragon/ 由相同顏色棋子的串組成，將被視為一個單位。龍在每一次走子后都會重新生成。
如果有兩個串在龍中，電腦假設它們具有有效連接並且共同生存或死亡。

Dragon 代碼的目的是讓電腦制定關於圍棋死活的有意義的陳述，舉個例子，考慮以下情況：

#+BEGIN_EXAMPLE
      OOOOO
     OOXXXOO
     OX...XO
     OXXXXXO
      OOOOO
#+END_EXAMPLE

X 區域應被視為一個單組（a single group），並有一個含三個交叉點的眼，但由兩個分離
的串組成，因此我們必須將這兩個串合併成一條單獨的龍，這個斷言之所以有意義，是由於
如果我們在中心點落子，將會殺死或做活這條龍，這對雙方都至關重要。如果 X 區域不
被視為一個單元，那麼將很難指定這個條件。

#+BEGIN_EXAMPLE
      Death            Life

      OOOOO            OOOOO
     OOXXXOO          OOXXXOO
     OX.O.XO          OX.X.XO
     OXXXXXO          OXXXXXO
      OOOOO            OOOOO
#+END_EXAMPLE

目前 dragon 代碼的實現涉及簡化假設，這些假設可以在以後的實現中得到細化。

** Worms

   數組 =struct worm_data worm[MAX_BOARD]= 保存了關於蠕蟲的信息，我們將給出各個
   字段的定義，每個字段在蠕蟲的每個頂點都有恆定值。 我們將定義每個字段：

#+BEGIN_SRC c
  struct worm_data {
      int   color;
      int   size;
      float effective_size;
      int   origin;
      int   liberties;
      int   liberties2;
      int   liberties3;
      int   liberties4;
      int   lunch;
      int   cutstone;
      int   cutstone2;
      int   genus;
      int   inessential;
      int   invincible;
      int   unconditional_status;
      int   attack_points[MAX_TACTICAL_POINTS];
      int   attack_codes[MAX_TACTICAL_POINTS];
      int   defense_points[MAX_TACTICAL_POINTS];
      int   defend_codes[MAX_TACTICAL_POINTS];
      int   attack_threat_points[MAX_TACTICAL_POINTS];
      int   attack_threat_codes[MAX_TACTICAL_POINTS];
      int   defense_threat_points[MAX_TACTICAL_POINTS];
      int   defense_threat_codes[MAX_TACTICAL_POINTS];
  };
#+END_SRC

- =color=

  蠕蟲的顏色（黑或白）

- =size=

  包含了蠕蟲的基數

- =effective_size=

  一隻蠕蟲中的棋子數加上空交叉點數，空交叉點和這隻蠕蟲的距離不會比和其他蠕蟲的距
  離更遠。共享的交叉點數被計算為每隻蠕蟲的平均值，并用於測量所捕獲的一隻蠕蟲的直
  接領土價值, /=effective_size=/ 是一個浮點數。 只有當交叉點和串的距離小於等於 4
  時才會被計算。

- =origin=

  每一個串都有一個代表性成員，被稱之為 “起點”，我們通過比較兩個節點的“起點”
  來確定這兩個節點是否在同一串棋子中。同樣如果我們希望對每一個串棋子進行測試，只
  需在起點執行它，而忽略其他節點。測試的特征是：

  #+BEGIN_SRC c
  worm[pos].origin == pos
  #+END_SRC


- =liberties=
- =liberties2=
- =liberties3=
- =liberties4=

  對於非空的串，字段 liberties 表示氣，並且分別被 LIBERTIES2，LIBERTIES3，和
  LIBERTIES4 所補充，分別代表氣的第二階，第三階，以及第四階數字。氣表明棋子周圍
  的空交叉點數，定義階數大於 1 用於探測周圍的空交叉點，特別是檢查一組棋子周圍是
  否足夠寬鬆。氣的階數 n 是指最少可以放置 n 個棋子來連接到相同顏色的串，當棋子和
  串的距離大於 1時，棋子周圍不能有相反顏色的棋子，通過打劫來連接是不允許的。因此
  以下的形狀對應的氣及其高階形式表達如下：

  #+BEGIN_EXAMPLE
          .XX...    We label the     .XX.4.
          XO....    liberties of     XO1234
          XO....    order < 5 of     XO1234
          ......    the O group:     .12.4.
          .X.X..                     .X.X..
  #+END_EXAMPLE

  高階氣的周圍不能有相反顏色的棋子，意味著棋子可以有跳、大跳、飛、大飛等活動，可
  以用於評估串是否被包圍。

  如果距離氣為 1 的位置放置了兩顆相反顏色的棋子（小尖的位置），意味著 O 棋子被兩
  個 X 棋子在左邊阻擋：

  #+BEGIN_EXAMPLE
          X.
          .O
          X.
  #+END_EXAMPLE

  我們將 n 稱之為氣的階數 n 和龍的距離。

- =lunch=

  如果非零， /lunch/ 指向一個容易被捕捉（提子）的位於邊界的串。（這個串是否可以
  防守並不重要。）

我們有兩種截然不同分割棋子的概念，分別在字段 =worm.cutstone= 和 =worm.cutstone2=
中保持追蹤。我們目前並行使用這兩種概念。

- =cutstone=

  這個字段等於 2 時表明正在分斷棋子，1 表明可能在分斷。否則為 0。這個字段的定義：
  一個子分斷了敵方兩股棋子，並且沒有公氣。最常見的分斷情況如下：

  #+BEGIN_EXAMPLE
          XO
          OX
  #+END_EXAMPLE

  一個可能的分斷情況如下（X）：

  #+BEGIN_EXAMPLE
          XO
          O.
  #+END_EXAMPLE

  對於處於分斷的情況，我們設置：

  #+BEGIN_SRC c
  worm[].cutstone=2
  #+END_SRC

  對於將要分斷的情況，我們設置：

  #+BEGIN_SRC c
  worm[].cutstone=1
  #+END_SRC


- =cutstone2=

  斷點由連接數據庫(connections database)中的模式所標識。攻擊或防禦，以及連接或切
  斷大龍，都會引起斷點的產生。 =cutstone2= 字段被 =find_cuts()= 例程所設置，此例
  程被 =make_domains()= 函數調用。

- =genus=

  虧格對串和龍分別有不同的意義。對於龍來說更為重要，因此 =dragon[pos].genus= 遠
  比 =worm[pos].genus= 更為有用。兩個字段都用於評估眼位大致的數量。蠕蟲的虧格是
  其補碼的聯通分量減去 1。這是對一串棋子眼位的大致數量的評估。

- =inessential=

  殘子是指沒有生命潛力的棋子，除非包圍其的敵子被殺死。殘子更準確的定義是指虧格為
  0 的棋子，並且其周圍的敵子不能輕易地被捕獲，而且其氣較緊或者沒有二階氣，並且滿
  足以下屬性：如果這一串棋子被從棋盤上移走，剩下的空腔必與敵方的棋子接壤。

- =invincible=

  永生的棋子是指 GNU Go 覺得不能被提走的串。永生的棋子由函數
  =unconditional_life()= 所計算，它試圖找到那些不能被提走的棋子，即使對手可以連
  續下任意步。

- =unconditional_status=

  無條件狀態同樣被函數 =unconditional_life= 所設置。如果棋子是活棋時（明確地有兩
  個或兩個以上真眼）其值將被設置為 =ALIVE= ，反之即為 =DEAD= 。不屬於對手活棋眼
  位的空交叉點被稱之為無條件領土（unconditional territory）。取決於領土的歸屬，
  其無條件狀態將被設為 =WHITE_TERRITORY= 或者 =BLACK_TERRITORY= 。最後，如果棋子
  可以被捕捉，但是其與己方的無條件領土相鄰，那麼其無條件狀態亦被設為 =ALIVE= 。除此
  之外的所有情況，無條件狀態都被設為 =UNKNOWN= 。

  要理解這些定義，重要的是要注意，任何普通意義上的活棋通過一系列連續的落子，都能
  轉變成永生狀態（invincible）。當然，也有少數情況是例外，比如“雙活”。可以通過
  一些稍微複雜的算法來避免這個問題，但這將留待以後的修改。

- =int attack_points[MAX_TACTICAL_POINTS]=
- =attack_codes[MAX_TACTICAL_POINTS]=
- =int defense_points[MAX_TACTICAL_POINTS];=
- =int defend_codes[MAX_TACTICAL_POINTS];=

  當戰術代碼（tactical reading code）發現一串棋子可被攻擊， =attack_points[0]=
  是攻擊點， =attack_codes[0]= 是攻擊碼，為 =WIN= ， =KO_A= 或者 =KO_B= 。對於已
  知的多重攻擊， =attack_points[k]= 和 =attack_codes[k]= 將被使用。對於防守碼和
  防守點也有相似的定義。

- =int attack_threat_points[MAX_TACTICAL_POINTS];=
- =int attack_threat_codes[MAX_TACTICAL_POINTS];=
- =int defense_threat_points[MAX_TACTICAL_POINTS];=
- =int defense_threat_codes[MAX_TACTICAL_POINTS];=

  這些點威脅攻擊或保護一串棋子。

函數 =makeworms()= 將會產生所有蠕蟲的數據。

** 合併
<<amalgamation>>
如前所述，龍是一組被視為一個整體的棋子，這些棋子將共同生存或死亡。因此如果對方的
一串棋子被視為一條龍，則程序不會試圖去切斷它。

函數 =make_dragons()= 會通過維護包含相似數據的獨立數組 =worm[]= 和 =dragon[]= 將
棋子串合併成龍。每一條龍是蠕蟲的合并，正如對於每一串棋子， 維護在 =worm[]= 中的
數據是固定的，對於每一條龍，在 =dragon[]= 中的數據也是固定的。

在 GNU Go 中合併棋子串的操作如下。首先，我們合併一個眼型的所有邊界部分。因此，在
下面的例子中：

#+BEGIN_EXAMPLE
    .OOOO.          四個 X 棋子串被合併進龍， 因為它們是龍的邊界眼洞的一部分。
    OOXXO.          眼洞可能包含無關緊要的棋子串，對這種合併沒有影響。
    OX..XO
    OX..XO
    OOXXO.
    XXX...
#+END_EXAMPLE

這種類型合併的代碼在例程 =dragon_eye()= 中，在 EYES 中進一步討論。

接下來，我們合併看似不可分的棋子串。我們將合併具有兩個或者更多公共氣的龍，或者與
對方有一口公氣，但是對方卻不可以在不被提取的情況下落子的情形。（忽略打劫情況。）

#+BEGIN_EXAMPLE
   X.    X.X     XXXX.XXX         X.O
   .X    X.X     X......X         X.X
                 XXXXXX.X         OXX
#+END_EXAMPLE

連接模式的數據庫可以在路徑 ='patterns/conn.db'= 下找到。

** 連接

#+BEGIN_SRC c
  /* engine: liberty.h */
  struct eye_data {
      int color;             /* BLACK, WHITE, or GRAY                     */
      int esize;             /* size of the eyespace                      */
      int msize;             /* number of marginal vertices               */
      int origin;            /* The origin                                */
      struct eyevalue value; /* Number of eyes.                           */

      /* The above fields are constant on the whole eyespace.             */
      /* ---------------------------------------------------------------- */
      /* The below fields are not.                                        */

      unsigned char marginal;             /* This vertex is marginal               */
      unsigned char neighbors;            /* number of neighbors in eyespace       */
      unsigned char marginal_neighbors;   /* number of marginal neighbors          */
  };

  /* engine: global.c */
  struct eye_data       black_eye[BOARDMAX];
  struct eye_data       white_eye[BOARDMAX];
#+END_SRC

  字段 =black_eye.cut= 和 =white_eye.cut= 被設置為對方可以通過 ='conn.db'= 中的B
  類模式(Break class) 完成切斷。這個字段有兩個重要重要用途，可以通過autohelper
  函數 =xcut()= 和 =ocut()= 來訪問。首先，它可以用於停止對以下形狀的合併：

  #+BEGIN_EXAMPLE
..X..
OO*OO
X.O.X
..O..
  #+END_EXAMPLE

  當 X 方可以落子在 =*= 處去切斷任何一方，當第一個連接模式 CB1 發現了脆弱的雙切
  斷狀態，並且標註 =*= 為切斷點。稍後，將在 ='conn.db'= 搜索 C 類（connection）
  模式，以找到合併龍的安全連接。通常情況下，對角連接（小尖）被視為安全的，并被連
  接模式 CC101 合併，但是有一個約束條件是任何一個空的交叉點都不是一個切斷點。

  #+BEGIN_EXAMPLE
Pattern CC101

.O
O.
  #+END_EXAMPLE

  這個方案（CB1）的缺點是 X 只能切斷一處連接，而不是同時切斷兩邊。因此我們將允許
  通過連接模式 CC401 來合併其中一處連接，這個連接模式通過函數
  =amalgamate_most_valuable_helper()= 選擇連接哪一邊。（猜測具有較大價值的一邊。）

  另一個用途是簡化對實體連接的可選連接模式。 =diag_miai= （miai：見合）通過連接
  模式 12 輔助思考一個連接是否有必要被標記為斷點。因此我們可以寫出一個類似 =CC6=
  的連接模式：

  #+BEGIN_EXAMPLE
?xxx?     straight extension to connect
XOO*?
O...?

:8,C,NULL

?xxx?
XOOb?
Oa..?

;xcut(a) && odefend_against(b,a)
  #+END_EXAMPLE

=*= 處將被定義為防禦切斷。

** 半眼和假眼

半眼是指當我方落子時將變為真眼，但對方落子時將不能成為真眼的眼形；假眼是指可以被
對方破壞的眼形。注：雖然通常需要兩隻真眼才可活棋，但在某些特殊情況下，兩個假眼也
可以活棋（兩頭蛇、盤龍活）。以下是半眼的情況：

  #+BEGIN_EXAMPLE
XXXXX
OO..X
O.O.X
OOXXX
  #+END_EXAMPLE

以下是一個假眼：

  #+BEGIN_EXAMPLE
XXXXX
XOO.X
O.O.X
OOXXX
  #+END_EXAMPLE

“拓撲”算法描述了如何確定半眼或假眼（參見[[topology_of_eyes][Topology of Half Eyes and False Eyes]]）

半眼數據收集在龍陣列中。在此之前，在名為 =half_eye_data= 的輔助數組中填充了信息。
字段 =type= 為 =0= 、 =HALF_EYE= 、或者 =FALSE_EYE= 取決於眼是哪一種類型；字段
=attack_point[]= 指向了最多可以攻擊半眼的四個點，類似的 =defense_point[]= 給出了
半眼的防禦點。

#+BEGIN_SRC c
struct half_eye_data half_eye[MAX_BOARD];

struct half_eye_data {
  float value;          /* Topological eye value. */
  unsigned char type;   /* HALF_EYE or FALSE_EYE; */
  int num_attacks;      /* number of attacking points */
  int attack_point[4];  /* the moves to attack a topological halfeye */
  int num_defenses;     /* number of defending points */
  int defense_point[4]; /* the moves to defend a topological halfeye */
};
#+END_SRC

陣列 =struct half_eye_data half_eye[MAX_BOARD]= 包含了關於半眼和假眼的信息。如果
類型為 =HALF_EYE= 則最多記錄 4 個落子點，可以用於攻擊或保護眼位。極少情況攻擊點不
同於防禦點。

** Dragons
陣列 =struct dragon_data dragon[MAX_BOARD]= 收集了關於龍的信息。我們將會給出各個
字段的含義。每一個字段對於龍的每個頂點具有固定值。（我們將在下面討論字段。）

#+BEGIN_SRC c
/*
 * data concerning a dragon. A copy is kept at each stone of the string.
 */

struct dragon_data {
  int color;    /* its color                                                 */
  int id;       /* the index into the dragon2 array                          */
  int origin;   /* the origin of the dragon. Two vertices are in the same    */
                /* dragon iff they have same origin.                         */
  int size;     /* size of the dragon                                        */
  float effective_size; /* stones and surrounding spaces                     */
  enum dragon_status crude_status; /* (ALIVE, DEAD, UNKNOWN, CRITICAL)       */
  enum dragon_status status;       /* best trusted status                    */
};

extern struct dragon_data dragon[BOARDMAX];
#+END_SRC

附加到龍的其他字段包含在結構體陣列 =dragon_data2= 中。（以下將討論字段。）

#+BEGIN_SRC c
struct dragon_data2 {
  int origin;                         /* the origin of the dragon            */
  int adjacent[MAX_NEIGHBOR_DRAGONS]; /* adjacent dragons                    */
  int neighbors;                      /* number of adjacent dragons          */
  int hostile_neighbors;              /* neighbors of opposite color         */

  int moyo_size;		      /* size of surrounding influence moyo, */
  float moyo_territorial_value;       /* ...and its territorial value        */
  enum dragon_status safety;          /* a more detailed status estimate     */
  float weakness;           /* a continuous estimate of the dragon's safety  */
  float weakness_pre_owl;   /* dragon safety based on pre-owl computations   */
  float strategic_size; /* An effective size including weakness of neighbors */
  int escape_route;         /* a measurement of likelihood of escape         */
  struct eyevalue genus;    /* the number of eyes (approximately)            */
  int heye;     /* coordinates of a half eye                                 */
  int lunch;    /* if lunch != 0 then lunch points to a boundary worm which  */
                /* can be captured easily.                                   */
  int surround_status;         /* Is it surrounded?                          */
  int surround_size;           /* Size of the surrounding area               */

  int semeais;         /* number of semeais in which the dragon is involved  */
  int semeai_defense_code ;/* Result code for semeai defense.                */
  int semeai_defense_point;/* Move found by semeai code to rescue dragon     */
  int semeai_defense_certain;
  int semeai_defense_target; /* The opponent dragon involved in the semeai   */
  int semeai_attack_code ; /* Result code for semeai attack.                 */
  int semeai_attack_point; /* Move found by semeai code to kill dragon       */
  int semeai_attack_certain;
  int semeai_attack_target; /* The opponent dragon involved in the semeai    */
  enum dragon_status owl_threat_status; /* CAN_THREATEN_ATTACK/DEFENSE       */
  enum dragon_status owl_status; /* (ALIVE, DEAD, UNKNOWN, CRITICAL, UNCHECKED)    */
  int owl_attack_point;    /* vital point for attack                         */
  int owl_attack_code;     /* ko result code                                 */
  int owl_attack_certain;  /* 0 if owl reading node limit is reached         */
  int owl_attack_node_count;
  int owl_second_attack_point;/* if attacker gets both attack points, wins   */
  int owl_defense_point;   /* vital point for defense                        */
  int owl_defense_code;    /* ko result code                                 */
  int owl_defense_certain; /* 0 if owl reading node limit is reached         */
  int owl_second_defense_point;/* if defender gets both attack points, wins  */
  int owl_attack_kworm;    /* only valid when owl_attack_code is GAIN        */
  int owl_defense_kworm;   /* only valid when owl_defense_code is LOSS       */
};

/* dragon2 is dynamically allocated */
extern int number_of_dragons;
extern struct dragon_data2 *dragon2;
#+END_SRC

兩個陣列不同之處在於 =dragon= 陣列是由棋盤索引的，並且龍的每個棋子上都有一個數據
的副本，而 =dragon2= 數據只有一個副本。 =dragons= 被編號，並且 =id= 字段是進入
=dragon2= 陣列的鍵值，提供了兩個宏 DRAGON 和 DRAGON2，用於訪問這兩個數組：

#+BEGIN_SRC c
#define DRAGON2(pos) dragon2[dragon[pos].id]
#define DRAGON(d) dragon[dragon2[d].origin]
#+END_SRC

因此，如果你知道棋子在龍之中的位置，就可以直接訪問龍陣列，例如使用
=dragon[pos].origin= 訪問起點。但是，如果你需要來自 =dragon2= 的字段，你可以使用
DRAGON2 宏來訪問它，比如你可以訪問鄰近的龍：

#+BEGIN_SRC c
  for (k = 0; k < DRAGON2(pos).neighbors; k++) {
      int d = DRAGON2(pos).adjacent[k];
      int apos = dragon2[d].origin;
      do_something(apos);
  }
#+END_SRC

同樣如果你知道龍的編號（即 =dragon[pos].id= ），就可以直接訪問 =dragon2= 陣列，
或者使用 DRAGON 宏來訪問。

這裡是 =dragon= 陣列中每個字段的含義：

- =color=

  龍的顏色。

- =id=

  龍的編號以及進入 =dragon2= 的鍵值。

- =origin=

  龍的起點是指一個獨特的頂點，用於確定兩個頂點何時屬於同一條龍。在合併之前，串的
  起點被複製到龍的起點。兩條龍的合併就是改變其中一條龍的起點。

- =size=

  龍之中的棋子數目。

- =effective size=

  組成龍的蠕蟲的有效尺寸之和。注意蠕蟲的有效尺寸包含了等距離的空交叉點，因此龍的
  有效尺寸包含了基數再加上接近的空交叉點數。

- =crude_status=

  (ALIVE, DEAD, UNKNOWN, CRITICAL). 龍的生命潛力的早期預測。它是在 owl 代碼運行
  之前進行計算，並在狀態變為可用時由狀態取代。

- =status=

  龍的狀態是衡量龍的健康的最好標準。它在運行 owl 代碼之後進行計算，然後在運行
  semeai（對殺） 代碼時再次修改。

以下是 dragon2 陣列中的字段定義。

- =origin=

  和 =dragon= 中的 =origin= 字段定義相同。

- =adjacent=
- =adjacent[MAX_NEIGHBOR_DRAGONS]=

  在給定一種顏色附近的龍被稱為鄰居。它們通過函數 =find_neighbor_dragons()= 計算。
  =dragon2.adjacent= 數組給出了這些龍的數量。

- =neighbors=

  鄰近龍的數量。

- =hostile_neighbors=

  相反顏色的鄰近龍的數量。

- =moyo_size=
- =float moyo_territorial_value=

  函數 =compute_surrounding_moyo_sizes()= 為每條龍周圍的模樣指定一個大小和一個地
  域值 （參閱 [[territory][Territory, Moyo and Area]] ）。

- =safely=

  龍的安全性可由以下指標衡量：

  - =TACTICALLY_DEAD= - 由單個蠕蟲組成的龍，由 reading code 發現死亡 （非常可靠）。

  - =ALIVE= - 由 owl 或 semeai（對殺） 代碼發現存活。

  - =STRONGLY_ALIVE= - 存活沒有太大問題。

  - =INVINCIBLE= - 即使一直脫先也可以存活。

  - =ALIVE_IN_SEKI= - 由 semeai（對殺） 代碼發現為共活。

  - =CRITICAL= - 生或死取決於誰落子。

  - =DEAD= - 由 owl 代碼發現為死棋。

  - =INESSENTIAL= - 龍是無關緊要的（如 nakade stones）以及死子。

- =weakness=
- =weakness_pre_owl=

  用於衡量龍的安全性的浮點值。龍的弱點是一個介於 0. 和 1. 之間的數字，數字越大說
  明對安全性的要求更高。字段 =weakness_pre_owl= 是 owl 代碼運行之前的初步計算。

- =escape_route=

  當不能就地做活時，評估龍逃生的可能性。文檔可以在[[escape][Escape]]中找到。

- =struct eyevalue genus=

  預計龍可以獲得的大概眼位數量。不能保證是準確的。整個引擎中使用的 =eyevalue= 結構
  體聲明如下：

#+BEGIN_SRC c
struct eyevalue {
  unsigned char a; /* number of eyes if attacker plays first twice */
  unsigned char b; /* number of eyes if attacker plays first */
  unsigned char c; /* number of eyes if defender plays first */
  unsigned char d; /* number of eyes if defender plays first twice */
};
#+END_SRC

- =heye=

  龍的半隻眼的位置。

- =lunch=

  如果非零，這是可以被吃掉的邊界棋子串的位置。與蠕蟲 lunches 相反，一個龍的
  lunch 必須能夠自我防禦。

- =surround_status=
- =surround_size=

  去評估龍是否安全的一個重要因素是知道其是否被包圍。在[[surround][Surrounded and Dragons]]中以
  及 ='surround.c'= 的注釋中可以獲得關於“包圍”算法的更詳細信息。此字段用於計算
  =escape_route= ，也可以從模式中調用（目前由CB258使用）。

- =semeais=
- =semeai_defense_point=
- =semeai_defense_certain=
- =semeai_attack_point=
- =semeai_attack_certain=

  如果兩條糾纏的相反顏色的龍同時處於 CRITICAL 或 DEAD 狀態，則稱之為 /semeai/
  （對殺），並且它們的狀態必須由 ='owl.c'= 中的函數 =owl_analyze_semeai()= 來判
  定，它試圖確定哪些是活棋，哪些是死棋，或者共活，以及誰先落子是否重要。
  ='semeai.c'= 中的函數 ='new_semeai()'= 嘗試修訂狀態並基於這些結果生成走子依據。
  如果龍處於對殺狀態，字段 =dragon2.semeais= 的值非零，並且等於對殺的數目（很少
  超過1）。對殺的防守和攻擊點是防守者或攻擊者為贏得對殺而必須落子的點。字段
  =semeai_margin_of_safety= 旨在表明對殺是否結束，但目前該字段未被維護。字段
  =semeai_defense_certain= 和 =semeai_attack_certain= 表明 =semeai= 代碼能夠完成
  分析而不會耗盡節點。

- =owl_status=

  這是一個類似于 =dragon.crude_status= 的分類，但是基於對代碼 ='owl.c'= 中對死活
  的解讀。 owl 代碼 （參見章節[[owl][The Owl Code]]）被跳過，因為某些啟發式算法似乎是安全
  的。由於 owl 代碼未運行，因此 owl 狀態是 =UNCHECKED= 。如果 =owl_attack()= 確
  定龍不會被攻擊，則被分類為 =ALIVE= 。否則，運行 =owl_defend()= ，如果有效，狀態
  就是 =CRITICAL= ，如果不能，就被歸類為 =DEAD= 。

- =owl_attack_point=

  龍受攻擊的點。

- =owl_attack_code=

  owl 攻擊代碼，可以是 =WIN= ， =KO_A= ， =KO_B= ，或者 =0= 。（參考 [[return_code][Return Codes]]）。

- =owl_attack_certain=

  owl 代碼能夠完成攻擊分析而不會耗盡節點。

- =owl_second_attack_point=

  第二個攻擊點。

- =owl_defense_point=

  龍的防守點。

- =owl_defense_code=

  owl 防守代碼，可以是 =WIN= ， =KO_A= ， =KO_B= ，或者 =0= 。（參考 [[return_code][Return Codes]]）。

- =owl_defense_certain=

  owl 代碼能夠完成防守分析而不會耗盡節點。

- =owl_second_defense_point=

  第二個防守點。

** 龍的色彩顯示

你可以採用彩色的 ASCII 碼顯示棋盤，其中每條龍被分配一個不同的字母，並且
=dragon.status= 不同的值（ =ALIVE, DEAD, UNKNOWN, CRITICAL= ），對應不同的顏色，
這對於調試非常方便。第二個圖顯示了 =owl.status= 的值，如果是 =UNCHECKED= 則龍顯
示為白色。

使用 CGoban 將棋局保存為 sgf 格式，或者使用 GNU Go 自身的 ='-o'= 選項來保存棋局。

打開 =xterm= 或者 =rxvt= 窗口，或者使用 Linux 控制台。通過控制台，你可以使用
"SHIFT-PgUp" 來看第一個圖。Xterm 只有當顏色支持的情況下編譯才能使用 -- 如果您看
不到顏色，請嘗試 =rxvt= 。請設置背景色為黑色，前景色為白色。

執行：

#+BEGIN_SRC sh
gnugo -l [filename] -L [movenum] -T
#+END_SRC

來獲得顏色顯示。

配色方案：綠色 = =ALIVE= ；黃色 = =UNKNOWN= ；青色 = =DEAD= 以及 紅色 =
=CRITICAL= 。已經合併成同一條龍的蠕蟲標有相同字母。

其他有用的彩色顯示可以通過使用：

- 選項 -E 顯示眼位空間 （參考 [[eyes_and_halfeyes][Eyes and HalfEyes]]）。
- 選項 -m 0x0180 顯示領土、模樣和地區（參考 [[territory][Territory, Moyo and Area]]）。

關於彩色顯示也可以參考其他地方（參考 [[colored_display][Colored Displayed]]）。

* Eyes and Half Eyes
<<eyes_and_halfeyes>>
本章的目的是描述 GNU Go 用於確定眼位的算法。
** 局部博弈
組合博弈論的基本範式是遊戲可以被疊加並且實際形成一個群組。如果 ='G'= 和 ='H'= 都
是遊戲，那麼 ='G+H'= 也是一個遊戲，輪到走子的玩家可以有任意的選擇。我們說遊戲
'=G+H'= 是局部博弈 ='G'= 和 ='H'= 的和。

龍的每一個相關聯的眼位空間都提供一個局部博弈，它產生一個局部博弈樹。這個局部博弈
的得分是它產生眼位的數量。通常如果玩家輪流做出最佳選擇，最終的得分將相差 0 或 1。
在這種情況下，局部博弈可以用一個整數或半整數來表示。因此如果 ='n(O)'= 是 ='O'=
方先手的得分，兩個玩家交替走子（沒有脫先），並且類似地定義 ='n(X)'= ，則遊戲可以
表示為 ='{n(O)|n(X)}'= 。因此 {1|1} 是一個眼，{2|1} 是一個眼加上半個眼，等等。

特殊的遊戲 {2|0} 可能發生，儘管很少，我們稱這種開放眼形為 =CHIMERA= 。如果任何本
地博弈以2分或更高的分數結束，則代表龍仍然活著，所以 {2|1} 和 {3|1} 沒有區別。因
此 {3|1} 不是一個嵌合體。

以下是關於嵌合體的一個例子：

#+BEGIN_EXAMPLE
    XXXXX
    XOOOX
    XO.OOX
    XX..OX
    XXOOXX
    XXXXX
#+END_EXAMPLE

** 眼位空間
為了將眼位盡可能分配給龍，有必要將周圍的龍都合併進來（見[[amalgamation][Amalgamation]]）。這是
=dragon_eye()= 的功能。

對於一條龍來說，眼位空間是與龍相鄰的點集，可能是未完全封閉的空間，但是有可能成為
眼位。如果一個開放的眼位空間足夠大，可能會形成兩隻眼。眼形邊緣的交叉點（與眼形之外的
空交叉點相鄰）稱之為 =MARGINAL= 。

這裡以一局遊戲為例：

#+BEGIN_EXAMPLE
 |. X . X X . . X O X O
 |X . . . . . X X O O O
 |O X X X X . . X O O O
 |O O O O X . O X O O O
 |. . . . O O O O X X O
 |X O . X X X . . X O O
 |X O O O O O O O X X O
 |. X X O . O X O . . X
 |X . . X . X X X X X X
 |O X X O X . X O O X O
#+END_EXAMPLE

這裡中間環繞 ='O'= 龍有開放的眼位空間。在開放眼位的中部有三個已死的 ='X'= 棋子。
這裡 ='O'= 的眼位足夠大因而不會被殺死。我們可以抽象出這種眼形的性質如下，將某些
交叉點標記如下：

#+BEGIN_EXAMPLE
 |- X - X X - - X O X O
 |X - - - - - X X O O O
 |O X X X X - - X O O O
 |O O O O X - O X O O O
 |! . . . O O O O X X O
 |X O . X X X . ! X O O
 |X O O O O O O O X X O
 |- X X O - O X O - - X
 |X - - X - X X X X X X
 |O X X O X - X O O X O
#+END_EXAMPLE

所討論的眼形有如下形式：

#+BEGIN_EXAMPLE
!...
  .XXX.!
#+END_EXAMPLE

邊緣交叉點用感歎號（ ='!'= ）標記。在眼位空間中被捕獲的 ='X'= 棋子很自然地被標記
為 ='X'= 。

確定眼位空間的算法有些複雜。該算法在函數 =make_domains()= 的注釋中（位於源文件
='optics.c'= ）。

通過運行 =gnugo -E= ，可以使用彩色 ascii 圖表方便地顯示眼形。

** 眼位作為局部博弈
抽象地說，眼位可以由以下一組標記的交叉點表示：

#+BEGIN_EXAMPLE
!  .  X

. - ordinary eye space
! - marginal eye space
X - dead opponent stone
#+END_EXAMPLE

在數據庫 ='patterns/eyes.db'= 中可以找到許多關於眼位的模式，每一個都被認為是一個
局部博弈。遊戲的結果以 =:max,min= 的形式列在眼形之後， 其中 =max= 是當 ='O'= 先
手時產生的眼位數量， =min= 是當 ='X'= 先手時產生的眼位數量。在整個討論中，擁有眼
位的一方被標記為 ='O'= 。從活棋的角度說，由於三隻眼并不比兩隻眼更好，所以沒有試
圖判斷空間是否產生兩隻眼睛或三隻眼睛，因此最大值從不超過 2。表中省略了 min > 1
的模式。

舉例來說，我們有：

#+BEGIN_EXAMPLE
Pattern 548

 x
xX.!

:0111
#+END_EXAMPLE

這裡的符號如上所述，除了 ='x'= 表示 ='X'= 或者 =EMPTY= ，這個模式的結果和 ='x'=
處是否有子并無影響。

我們可以如下概括局部博弈：兩名玩家 ='O'= 和 ='X'= 輪流落子，或者 pass。

- RULE 1: ='O'= 在落子時會刪除標記為 ='!'= 或 ='.'= 的交叉點。

- RULE 2: ='X'= 在落子時將會替換 ='.'= 替換為 ='X'= 。

- RULE 3: ='X'= 可以刪除 ='!'= 節點。在這種情況下，與被刪除的 ='!'= 相鄰的
  ='.'= 交叉點都將被替換為 ='!'= 。如果一個 ='X'= 毗鄰被刪除的 ='!'= ，那麼 ='X'=
  和任何連接到它的 ='X'= 也被刪除。與被刪除的 ='X'= 相鄰的任何 ='.'= 保持不變，仍
  為 ='.'= 。

因此如果 ='O'= 先手，則他可以將眼位變成如下形狀：

#+BEGIN_EXAMPLE
(start)
!...
  .XXX.!

('O' moves first)
 ...            or      !...
  .XXX.!                  .XXX.
#+END_EXAMPLE

但如果 ='X'= 先落子，他可能會移除 ='!'= 從而鄰近 ='!'= 的 ='.'= 將會變成 ='!'=
。因此如果 ='X'= 先手，則眼位可以變成如下形狀：

#+BEGIN_EXAMPLE
(start)
!...
  .XXX.!

('X' moves first)
 !..            or      !...
  .XXX.!                  .XXX!
#+END_EXAMPLE

注意：在 ‘X:1’，‘O:2’ 交替落子之後有一個細微差別， ='O'= 威脅著捕獲三顆 X 棋
子，因此在 2 的位置左邊有半隻眼。 [fn::譯者注：作者此處的意思可能指如果 X 棋子是
死子，那麼 2 的位置隱藏著半隻眼。] 這是微妙的，並且仍有其他類似的微妙之處使得我
們的抽象描述無法概括。但至少有一些可以通過對方案的改進來處理，所以我們暫時可以滿
足這個簡化的模型。

#+BEGIN_EXAMPLE
 |- X - X X - - X O X O
 |X - - - - - X X O O O
 |O X X X X - - X O O O
 |O O O O X - O X O O O
 |1 2 . . O O O O X X O
 |X O . X X X . 3 X O O
 |X O O O O O O O X X O
 |- X X O - O X O - - X
 |X - - X - X X X X X X
 |O X X O X - X O O X O
#+END_EXAMPLE

我們沒有試圖去說明局部博弈的終止狀態（有些可能是共活）或者評分。

** 一個例子
這是一個局部博弈，無論誰先落子，都只會產生一隻眼：

#+BEGIN_EXAMPLE
!
...
...!
#+END_EXAMPLE

以下是幾種變化，假設 ='O'= 先走。

#+BEGIN_EXAMPLE
!        (start position)
...
...!


...      (after ‘O’'s move)
...!


...
..!


...       (刀把五)
..


.X.       (點殺)
..
#+END_EXAMPLE

另一種變化：

#+BEGIN_EXAMPLE
!         (start)
...
...!


!         (after ‘O’'s move)
. .
...!


!         (after ‘X’'s move)
. .
..X!


. .
..X!


. !
.!
#+END_EXAMPLE

** 圖
一個有用的觀察結果是，與眼位有關的局部博弈僅僅依賴依賴於底層圖形，該圖形由一組頂
點組成，其中兩個相鄰元素通過邊連接。如下是具備兩個眼位的形狀：

#+BEGIN_EXAMPLE
..    （曲四）
 ..

and

....  （直四）
#+END_EXAMPLE

由於不同的形狀可以是同構的，因此作為局部博弈也是同構的。這樣就縮小了在數據庫
='patterns/eyes.db'= 中儲存眼形的數量。

通過對半眼和假眼的處理，我們得到了進一步簡化。這些模式通過拓撲分析來識別（參考
[[topology_of_eyes][Topology of Half Eyes and False Eyes]]）。

一個半眼與模式（!.）同構。要了解這一點，請考慮以下兩個眼形：

#+BEGIN_EXAMPLE
XOOOOOO
X.....O
XOOOOOO

and:

XXOOOOO
XOa...O
XbOOOOO
XXXXXXX
#+END_EXAMPLE

都是等價的眼形，具有同構的局部博弈 {2|1}。第一個圖形具有形狀：

#+BEGIN_EXAMPLE
!....
#+END_EXAMPLE

第二個眼形在 ='a'= 具有半只眼（當 ='O'= 或 ='X'= 落子在 ='b'= 處），這是由拓撲判
定所發現的。（參考[[topology_of_eyes][Topology of Half Eyes and False Eyes]]。）

對於以上幾個圖，在匹配的過程中，將 ='....'= 左邊的 ='.'= 替換為 ='!.'= 。

一個假眼同構于模式 =(!)= 。為了明確這一點，考慮以下眼形：

#+BEGIN_EXAMPLE
  xxxoooooo
  x.oa....o
  xxxoooooo
#+end_example

等價于前兩個眼形，和局部博弈 {2|1} 同構。

眼形在 ='a'= 處有一個假眼，一樣可被拓撲判定所發現。

對於上圖，在圖匹配的過程中，將 ='.....'= 左邊的 ='.'= 替換為 ='!'= ，這里直接通
過眼位數據，而不通過圖形匹配。

** 眼位分析
數據庫 ='patterns/eyes.db'= 中的模式被編譯成源代碼 ='patterns/eyes.c'= 中的數組
所表示的圖形。

每個實際在棋盤上出現的眼位空間都會被編譯成一個圖。半眼的處理方法如下，參考例子：

#+BEGIN_EXAMPLE
  XXOOOOO
  XOa...O
  XbOOOOO
  XXXXXX
#+END_EXAMPLE

重複之前的討論， ='b'= 處的交叉點作為一個邊界點添加到眼位空間中。圖中的鄰接條件
是一個宏（定義在 ='optics.c'= 中）：如果兩個頂點在物理上是相鄰的，或者一個是半眼，
另一個是關鍵點，則兩個頂點相鄰。

在 =recognize_eyes()= 中，來自實際眼位空間的每個這樣的圖，都與源代碼 ='eyes.c'=
中的圖進行匹配。如果發現一個匹配，則局部博弈的結果就已知了。如果圖不能被匹配，則
局部博弈的結果假設為 {2|2}。

** 眼位的局部博弈價值
=’eyes.db'= 中的遊戲值以簡化方式給出，該方式足夠靈活，可以有效地表示大多數可能
性。

模式下方的的冒號開始的行給出了匹配眼位的博弈價值。它由四個數字組成，每個數字是在以
下條件下獲得的真眼的數量：

1. 攻擊者先手並且由於防守者脫先，還允許再走一步。
2. 攻擊者先手且防守者在局部回應。
3. 防守者先手且攻擊者在局部回應。
4. 防守者先手並且由於攻擊者脫先，還允許再走一步。

第一種情況並不意味著攻擊者可以連續兩次落子，稍後將以一個例子解釋。

同樣的，由於兩隻真眼已是凈活，所有更多的真眼都被視為兩隻真眼。

以下15種情況值得關注：

- 0000：沒有眼。
- 0001：沒有眼，但是防守方可以威脅做出一隻眼。
- 0002：沒有眼，但是防守方可以威脅做出兩隻眼。
- 0011：1/2 眼，防守方先手可以做出一隻眼，攻擊方先手則沒有眼。
- 0012：3/4 眼，3/2 個眼如果防守方先手，攻擊方先手則沒有眼。
- 0022：1* 眼，如果防守方先手可以做出兩隻眼，攻擊方先手則沒有眼。
  [fn::譯者注：* 在此處指單官之意]
- 0111：一隻眼，攻擊方可以威脅破壞這隻眼。
- 0112：一隻眼，攻擊方可以威脅破壞這隻眼，防守方可以威脅做出另一隻眼。
- 0122：5/4 隻眼，防守方先手可以獲得兩隻眼，攻擊方先走則只有半隻眼。
- 0222：兩隻眼，攻擊方可以威脅破壞兩隻眼。
- 1111：一隻眼。
- 1112：一隻眼，防守方可以威脅做出另一隻眼。
- 1122：3/2 隻眼，防守方先手可以做出兩隻眼，攻擊方先手則只有一隻眼。
- 1222：兩隻眼，攻擊方可以威脅破壞一隻眼。
- 2222：兩隻眼。

3/4，5/4，和 1* 眼位值正如 Howard Landman 的論文 /Eyespace Values in Go/ 中所描述
的那樣。攻擊點和防禦點只有當明確影響眼位值的情況下才會在模式中進行標記，僅僅是純
粹的威脅并沒有標記。

所有不同情況的例子都可以在這個文件中找到（ ='eyes.db'= )。其中一些可能有點違反直
覺，所以我們需要在這裡解釋一個重要的例子。考慮模式：

#+BEGIN_EXAMPLE
Pattern 6141

 X
XX.@x

:1122
#+END_EXAMPLE

與如下位置匹配：

#+BEGIN_EXAMPLE
.OOOXXX
OOXOXOO
OXXba.O
OOOOOOO
#+END_EXAMPLE

現在看起來 ='X'= 可以通過 ='a'= 和 ='b'= 來做出兩眼，從而給出 =0122= 的眼位值。
這就是眼位值中第一個數字定義的微妙之處。這並不是說攻擊者必須連續在局部落子兩次，
而是說他被允許再走一步。這種形狀的關鍵屬性是當 ='X'= 落子在 ='a'= 處時將至少破壞
一隻眼， ='O'= 可以落子在 ='b'= 處，給出：

#+BEGIN_EXAMPLE
.OOOXXX
OO.OXOO
O.cOX.O
OOOOOOO
#+END_EXAMPLE

現在 ='X'= 可以繼續落子在 ='c'= 處從而保持 ='O'= 只有一個大眼，當 ='O'= 脫先時，
='X'= 沒有必要再落子，因為這個大眼是無法破壞的。因此上圖的眼位值是 =1122= 。

最後要注意的是，表示威脅的眼位值取決於允許自填滿，例如：

#+BEGIN_EXAMPLE
Pattern 301

X.X

:1222
#+END_EXAMPLE

在數據庫中，我們總是假設自填滿是允許的。很容易在不允許自填滿的情況下，在更高的層
次上理清這些下法。

** 半眼和假眼的拓撲結構
<<topology_of_eyes>>

半眼是指有機會變為真眼的眼形，取決於是誰先手。這裡有一個 ='O'= 的半眼：

#+BEGIN_EXAMPLE
   OOXX
   O.O.
   OO.X
#+END_EXAMPLE

假眼是無論誰先手，都不能成為真眼的眼形，以下是兩個假眼的例子：

#+BEGIN_EXAMPLE
   OOX         OOX
   O.O         O.OO
   XOO         OOX
#+END_EXAMPLE

我們現在描述用於發現半眼和假眼的拓撲算法。在本節中，我們忽略了劫。

假眼和半眼可以局部表徵為眼位中對角線交點的狀態。對於每種對角線交叉點，都有三種不
同的可能性：

- 被對方棋子佔據，並且不能被提走（對方是或棋）。
- 要麼為空，要麼對方可以安全地落子，或者被對方棋子佔據，同時也可以攻擊或防守。
- 被本方棋子佔據，或者被對方殘子佔據，或者雖然是空的，但對方並不能安全的落子于此
  處。

對以上三種可能性分別賦值2,1,0。總結對角線交叉點的值，我們有如下準則：

- sum >= 4: 假眼
- sum == 3: 半眼
- sum <= 2: 真眼

如果眼位是在邊上，則以上數字要相應減去2。另一種方法是將棋盤外的對角線點賦值為1。
為了得到精確的等價性，我們必須給角上的點賦值為0，即兩個坐標都超出邊界的點。

找到假眼和半眼的算法是：

對於眼位中最多只有一個鄰點的所有眼位點，根據上述準則評估對角線點的狀態，并根據這
些值的總和來進行分類。

** “劫”的眼位拓撲
本節將對眼位拓撲結構的分析擴展到“劫”。我們將“劫”區分為對 ='O'= 有利和對
='X'= 有利：[fn::譯者注：作者想表達的可能是：對某一方的先手劫、二手劫、連環劫等]

#+BEGIN_EXAMPLE
.?O?   good for O
OO.O
O.O?
XOX.
.X..

.?O?   good for X
OO.O
OXO?
X.X.
.X..
#+END_EXAMPLE

我們初步設前者對角線值為 =a= ，後者對角線值為 =b= 。我們將會清楚的有 =0 < a < 1
< b < 2= 。將 =e= 作為拓撲眼值（仍然是4個對角線值的總和），我們將會得到以下性質：

#+BEGIN_EXAMPLE
e <= 2     - 真眼
2 < e < 3  - 比真眼差，比半眼好
e = 3      - 半眼
3 < e < 4  - 比半眼差，比假眼好
e >= 4     - 假眼
#+END_EXAMPLE

為了確定 =a= 和 =b= 合適的拓撲值，我們分析以下含有劫的典型眼形：

#+BEGIN_EXAMPLE
      .X..      略好於真眼
(a)   ..OO          e < 2
      OO.O
      O.OO      e = 1 + a
      XOX.
      .X..


      .X..      好於半眼，差於真眼
(a')  ..OO      2 < e < 3
      OO.O
      OXOO      e = 1 + b
      X.X.
      .X..


      .X..      好於半眼，差於真眼
(b)   .XOO      2 < e < 3
      OO.O
      O.OO      e = 2 + a
      XOX.
      .X..


      .X..      好於假眼，差於半眼
(b')  .XOO      3 < e < 4
      OO.O
      OXOO      e = 2 + b
      X.X.
      .X..


      .X..
      XOX.      略好於真眼
(c)   O.OO          e < 2
      OO.O
      O.OO      e = 2a
      XOX.
      .X..


      .X..
      XOX.      真眼，但殘留味道（連環劫）
(c')  O.OO      e ~ 2
      OO.O
      OXOO      e = a + b
      X.X.
      .X..


      .X..
      X.X.      比半眼好，比真眼差
(c'') OXOO      2 < e < 3
      OO.O
      OXOO      e = 2b
      X.X.
      .X..


      .X...
      XOX..     比半眼好，比真眼差
(d)   O.O.X     2 < e < 3
      OO.O.
      O.OO.     e = 1 + 2a
      XOX..
      .X...


      .X...
      XOX..     半眼，但殘留味道
(d')  O.O.X     e ~ 3
      OO.O.
      OXOO.     e = 1 + a + b
      X.X..
      .X...


      .X...
      X.X..     比假眼好，比半眼差
(d'') OXO.X     3 < e < 4
      OO.O.
      OXOO.     e = 1 + 2b
      X.X..
      .X...


      .X...
      XOX..     比假眼好，比半眼差
(e)   O.OXX     3 < e < 4
      OO.O.
      O.OO.     e =  2 + 2a
      XOX..
      .X...


      .X...
      XOX..     假眼，但殘留味道
(e')  O.OXX     e ~ 4
      OO.O.
      OXOO.     e = 2 + a + b
      X.X..
      .X...


      .X...
      X.X..     略差於假眼
(e'') OXOXX     4 < e
      OO.O.
      OXOO.     e = 2 + 2b
      X.X..
      .X...
#+END_EXAMPLE

看起來很明顯我們應該用：

#+BEGIN_EXAMPLE
(i)   a=1/2, b=3/2
#+END_EXAMPLE

但事實證明這有一些缺陷，也可以嘗試以下幾組值：

#+BEGIN_EXAMPLE
(ii)  a=2/3, b=4/3
(iii) a=3/4, b=5/4
(iv)  a=4/5, b=6/5
#+END_EXAMPLE

總結上面的分析，我們得到了 =a= 和 =b= 四種不同選擇的下表：

#+BEGIN_EXAMPLE
case    symbolic        a=1/2   a=2/3   a=3/4   a=4/5   desired
        value           b=3/2   b=4/3   b=5/4   b=6/5   interval
(a)     1+a             1.5     1.67    1.75    1.8         e < 2
(a')    1+b             2.5     2.33    2.25    2.2     2 < e < 3
(b)     2+a             2.5     2.67    2.75    2.8     2 < e < 3
(b')    2+b             3.5     3.33    3.25    3.2     3 < e < 4
(c)     2a              1       1.33    1.5     1.6         e < 2
(c')    a+b             2       2       2       2           e ~ 2
(c'')   2b              3       2.67    2.5     2.4     2 < e < 3
(d)     1+2a            2       2.33    2.5     2.6     2 < e < 3
(d')    1+a+b           3       3       3       3           e ~ 3
(d'')   1+2b            4       3.67    3.5     3.4     3 < e < 4
(e)     2+2a            3       3.33    3.5     3.6     3 < e < 4
(e')    2+a+b           4       4       4       4           e ~ 4
(e'')   2+2b            5       4.67    4.5     4.4     4 < e
#+END_EXAMPLE

此處作者花了大量筆墨討論合適的取值，從而得到 =a=3/4= 或者 =a=1/2= 的結論。由於一
個眼形中同時出現三劫的情況非常少見，因此作者不做討論。從禁止同形反復的規則來說，
電腦計算的變化應該避免出現三劫的情況。

本章讓譯者不解的是，為什麼要通過估值而不是通過概率來區分眼位的價值？比如定義條件
概率：假眼變成真眼的概率為0，半眼變成真眼的概率為1/2，真眼本身就是真眼（概率為1）。
那麼首先討論 =(b)= 圖：

#+BEGIN_EXAMPLE
      .X..
(b)   .XOO
      OO.O
      O.OO
      XOX.
      .X..
#+END_EXAMPLE

對於 ='O'= 來說，記：

\begin{eqnarray*}
A   & = & {先手}\\
A^c & = & {後手}\\
B   & = & {真眼}
\end{eqnarray*}

那麼對於 =(b)= 圖可以畫出以下序貫圖：

#+CAPTION: probability tree of (b)
[[file:./prob_tree_b.jpg]]

注意在葉子 =P= 處出現了遞歸，利用概率可加性：

\begin{eqnarray*}
P(B) & = & \frac{1}{4}P(B) + \frac{1}{2} \\
P(B) & = & \frac{2}{3}
\end{eqnarray*}

可以對眼位的對角點使用相同的方法推斷概率，為了方便分析，定義：

適眼：後手落子，仍然有 50% 或以上可能性成為真眼的眼位（$P(B|A^c) \geq 50%$）。

失眼：先手落子，仍然不超過 50% 的可能性成為真眼的眼位（$P(B|A) \leq 50%$）。

對於圖 =(a)= ：

#+BEGIN_EXAMPLE
      .X..
(a)   .aOO
      OO.O
      ObOO
      XOX.
      .X..
#+END_EXAMPLE

由於先手必定形成真眼，只考慮後手的情況： ='X'= 有a、b兩個可選的落點，對於落點a，
='O'= 形成真眼的概率已論證為 2/3，對於落點b，就會形成 =(a')= 圖：

#+BEGIN_EXAMPLE
      .X..
(a')  ..OO
      OO.O
      OXOO
      X.X.
      .X..
#+END_EXAMPLE

對於圖 =(a')= ， ='O'= 先手可以形成真眼， 後手形成真眼的概率為 1/3，因此對於圖
=(a)= 可以畫出序貫圖：

#+CAPTION: probability tree of (a)
[[file:./prob_tree_a.jpg]]

這樣：

$$P(B|A^c) = \frac{1}{2} \times \frac{2}{3} + \frac{1}{2} \times \frac{2}{3} =
\frac{2}{3}$$

因此

$$P(B) = \frac{1}{2} + \frac{1}{2} \times \frac{2}{3} = \frac{5}{6}$$

我們仍然可以繼續考察圖 =(c)= 的 $P(B|A^c)$ ，事實上由於對稱性，圖 =(c)= 的
$P(B|A^c)$ 和 圖 =(c')= 的 $P(B)$ 相同，由於對於圖 =(c')= 來說，先手必形成一隻真
眼，仍然只考慮圖 =(c')= 的 $P(B|A^c)$ ：

#+BEGIN_EXAMPLE
      .X..           .X..
      XOX.           XOX.
(c)   O.OO     (c')  OaOO
      OO.O           OO.O
      O.OO           OXOO
      XOX.           XbX.
      .X..           .X..
#+END_EXAMPLE

當 ='X'= 落于 a 處時，如果 ='O'= 先手則形成真眼（搖頭劫），如果 ='O'= 後手則形成
真眼概率為 1/3；當 ='X'= 落于 b 處時， ='O'= 形成真眼的概率為 2/3。這樣對於圖
=(c')= ，P(B) = 2/3，對於圖 =(c)= ，P(B) = 5/6。

** 偽邊界
以下情況很少見，但需要特別注意：

#+BEGIN_EXAMPLE
   OOOOXX
   OXaX..
   ------
#+END_EXAMPLE

這裡 ='a'= 由於和 ='O'= 的眼位相鄰，並且毗鄰不能被攻擊的 ='X'= 棋子，但是 ='X'=
落子在 ='a'= 處將造成接不歸，因此我們稱 ='a'= 是偽邊界。

由於這個原因， ='O'= 的眼形應該解析為 =(X)= ，而不是 =(X!)= 。

** ='optics.c'= 中的函數
待譯

* Monte Carlo Go
Monte Carlo Go 引擎將隨機落子到最後，基於 UCT 算法（upper confidence bounds
applied to trees，上限置信區間演算法）從模式數據庫中產生落子點。這個算法使得
=MoGo= 成為第一個在 9 路棋盤上擊敗專家的程序。

#+CAPTION: Steps of Monte Carlo tree search (won/played)
[[file:./MCTS.jpg]]

GNU Go 3.8 可以在 9x9 棋盤上通過選項 ='--monte-carlo'= 來使用 UCT 算法。

在解讀的過程中，對於每一次落子，引擎會對局部的 3x3 鄰域進行增量更新，如自填滿狀
態、倒撲、以及提子個數等。

GNU Go 的模擬 （MC遊戲）是模式生成的。隨機生成的移動嚴格地與 3x3 鄰域組成的局部
場景中的表查找所計算出的移動值成比例分佈，局部場景包括包括對手的自殺狀態，自身及
對手的倒撲狀態，被自身或對手提子的個數，以及與前一次移動的接近程度等。我們將局部
場景簡稱為“一個模式（a pattern）”，將“模式值”表簡稱為“圖案（patterns）”。

GNU Go 有三種內置的數據庫，可以通過選項 ='--mc-patterns <name>'= 來指定，
='<name>'= 是以下其中之一：

=montegnu_classic=\\
=mogo_classic=    \\
=uniform=         

第一個是之前的隨機移動算法生成的近似值。 =mogo_classic= 模式值是對 MoGo 早期版本
所使用的模擬策略的近似值，由論文 [[https://hal.inria.fr/inria-00117266][Modiﬁcation of UCT with Patterns in Monte-Carlo
Go]] 所發表。而 =uniform= 模式值是所謂的“輕（light）”模擬，在除了單個真眼之外的所有合法移
動之中均勻地選擇。
 [fn:: 譯者注：“重（heavy）”模式是指採用各種啟發式算法來影響走子的選擇。根據譯
者測試，似乎 $uniform > montegnu\_classic \approx mogo\_classic$]

如果您不滿意，您還可以調整模式數據庫文件中的模式值，並在運行時使用
='--mc-patterns <name>'= 指定您自己的模式數據庫。

我們先從 =uniform= 模式值開始討論，它們定義在文件 ='patterns/mc_uniform.db'= ，
看上去類似以下：

#+BEGIN_EXAMPLE
oOo
O*O
oO?

:0

oOo
O*O
---

:0

|Oo
|*O
+--

:0
#+END_EXAMPLE

圖案的大小總是 3x3，以落子點為中心。這些符號通常用於 GNU Go 模式數據庫：

#+BEGIN_EXAMPLE
  * move
  O own stone (i.e. the same color as the color to move)
  o own stone or empty
  X opponent stone
  x opponent stone or empty
  ? own stone, opponent stone, or empty
  | vertical edge
  - horizontal edge
  + corner
#+END_EXAMPLE

這裡有一個新的符號：

#+BEGIN_EXAMPLE
  % own stone, opponent stone, empty, or edge
#+END_EXAMPLE

在模式圖案之後是以冒號開始的行。所有的圖案都將走子價值標記為 0，即為不能落子。不
匹配的圖案默認價值為1.當所有走子價值對於雙方都是0時，仿真將結束。以上三種模式非
常重要，否則仿真將可無期限地進行下去，或者實際上會以硬編碼的600次移動上限而終止
仿真。同時還要將這些模式放在數據庫的頂部，因為當多個模式匹配時，都會使用第一個模
式，無論其值是多少。

當使用這些模式時您可能會發現它的走子很“重”（不輕盈），總是試圖保持堅固的連接。
這是由於 uniform 仿真出現嚴重偏差，不牢固的連接被切斷的可能性很大。為了解決這個
問題，您可以嘗試如下的模式來增加受到威脅時單跳的可能性：

#+BEGIN_EXAMPLE
?X?
O*O
x.?

:20,near
#+END_EXAMPLE

在這裡，我們增加了“near”屬性，意味著該模式僅僅適用於本次落點“接近”于先前的落
點。“near”主要是指在 3x3 鄰域內，但也包括某些情況如氣緊的棋子接近之前的落子點，
比如長出被打吃的棋子，該棋子是先前的落子。你必須閱讀源代碼以找出“接近”的確切含
義。

我們也可以更具體地說：

#+BEGIN_EXAMPLE
?X?
O*O
x.?

:20,near,osafe,xsafe
#+END_EXAMPLE

以上模式，排除了倒撲或者將會是對手倒撲的情況（osafe, xsafe）。

看到棋子被提走也很有趣。一個提走全部棋子的模式將會是：

#+BEGIN_EXAMPLE
?X%
?*%
%%%

:10,ocap1,osafe
:20,ocap2
:30,ocap3
#+END_EXAMPLE

我們使用多個冒號開始的行來指定不同的移動值，具體取決於提取棋子的個數。價值10代表
提取單個棋子，價值20代表提取兩個棋子，價值30代表提取更多的棋子。這裡我們還排除了
當提取一個棋子時會形成倒撲的落點，用以避免模擬陷入三劫循環。（在模擬中沒有對禁全
同的偵測 [fn:superko]）。

[fn:superko] PSK(Positional Superko)：禁止使对方面对已经出现过的局面(Position),
简称禁全同。禁全同规则保证了棋局长度的有限。


全部的屬性模式如下：

- =near= :: The move is "near" the previous move.

- =far= :: The move is not "near" the previous move.

- =osafe= :: The move is not a self-atari.

- =ounsafe= :: The move is a self-atari.

- =xsafe= :: The move would not be a self-atari for the opponent.

- =xunsafe= :: The move would be a self-atari for the opponent.

- =xsuicide= :: The move would be suicide for the opponent

- =xnosuicide= :: The move would not be suicide for the opponent.

- =ocap0= :: The move captures zero stones.

- =ocap1= :: The move captures one stone.

- =ocap2= :: The move captures two stones.

- =ocap3= :: The move captures three or more stones.

- =ocap1+= :: The move captures one or more stones.

- =ocap1-= :: The move captures at most one stone.

- =ocap2+= :: The move captures two or more stones.

- =ocap2-= :: The move captures at most two stones.

- =xcap0= :: An opponent move would capture zero stones.

- =xcap1= :: An opponent move would capture one stone.

- =xcap2= :: An opponent move would capture two stones.

- =xcap3= :: An opponent move would capture three or more stones.

- =xcap1+= :: An opponent move would capture one or more stones.

- =xcap1-= :: An opponent move would capture at most one stone.

- =xcap2+= :: An opponent move would capture two or more stones.

- =xcap2-= :: An opponent move would capture at most two stones. 

這些屬性可以任意組合，但所有模式必須都滿足才能生效。如果矛盾的屬性相組合，模式將
永遠不匹配。

** 最後的註解

#+BEGIN_VERSE
移動值是無符號32位整數。為避免計算溢出，強烈建議將值保持在10000000以下。
數據庫中有許多模式沒有速度懲罰，每一步的平均時間大約是定值（稍微依賴於棋子被提取
或者變得氣緊的頻率），同時每局棋的時間依賴于遊戲的平均長度（手數）。
更多複雜的模式數據庫，參考 ='patterns/mc_montegnu_classic.db'= 和
='patterns/mc_mogo_classic.db'= 。
#+END_VERSE

沒有人真正知道如何調整隨機仿真以獲得盡可能強勁的引擎。請玩的同時報告任何有趣的發
現，特別是如果你能夠使它比 ='montegnu_classic'= 模式更強大。

* The Board Library
GNU Go 引擎的基礎是一個處理棋盤非常高效的例程庫。這個棋盤例程庫，稱之為
='libboard'= ，能夠用於那些只需要基本規則但不支持 AI 功能的程序。其中之一的程序
='patterns/joseki.c'= ，是從 SGF 文件編譯成定式模式庫。

如果你想在你自己的程序中使用這個例程庫，你需要所有位於 engine/Makefile.am 中的
=libboard_SOURCE= 下 [fn::GNU Go 3.8 是 =libboard_a_SOURCE= ]的 .c 文件，以及所
有位於目錄 sgf/ 和 utils/ 下的文件。同時你必須將頭文件 engine/board.h 放在你的代
碼中。

例程庫包含以外文件：

- ='board.h'= :: 棋盤庫的公共接口。
- ='board.c'= :: 基礎棋盤代碼。它使用增量算法來跟蹤圍棋盤上的棋子串及氣。
- ='boardlib.c'= :: 包含了棋盤庫的所有全局變量。
- ='hash.c'= :: 棋子位置哈希代碼。
- ='sgffile.c'= :: 以 SGF 格式輸出文件。
- ='printutils.c'= :: 用於打印圍棋棋盤及其他東西。

為了使用棋盤例程庫，必須包含頭文件 ='liberty.h'= ，正如使用整個引擎功能一樣，當
然你不能使用這個頭文件中所定義的所有函數，即作為引擎部分，但不是棋盤庫部分的那些
函數。你必須將你的應用程序與 =libboard.a= 文件鏈接起來。

** 棋盤數據結構
棋盤的基本數據結構與 =board_state= 結構（見[[the_board_state_struct][The board state struct]]）緊密結合。由
於效率的原因它們全部以全局變量的形式保存，最重要的內容如下：

#+BEGIN_EXAMPLE
int           board_size;
Intersection  board[MAXSIZE];
int           board_ko_pos;

float         komi;
int           white_captured;
int           black_captured;

Hash_data     hashdata;
#+END_EXAMPLE

這些變量也適用於對 =Position= 結構的描述，所以我們在這裡不再重複。由於性能原因，
所有這些變量都是全局的。在這些變量背後，還有一些其他的私有數據結構。這些實現了對
棋子串、氣和其他屬性的增量處理（參見[[incremental_board_data_structures][Incremental Board data structures]]）。變量
=hashdata= 包含了有關當前位置的散列值信息（參考[[hasing_of_positions][Hashing of Positions]]）。

不應該直接操縱這些變量，因為它們僅僅是增量器的前端。它們可以被讀取，但只能通過使
用下一節中描述的函數來編寫。如果你直接對它們進行寫入，增量數據結構將彼此不同步，
很可能導致崩潰。

** 棋盤陣列
GNU Go 用一個被稱為 =board= 的一維數組來刻畫棋盤。出於某些目的，可以使用參數
=(i,j)= 對棋盤進行二維索引。

=board= 陣列包含了圍繞棋盤外的標記。為了清楚地說明與舊的二維棋盤表示的關係，下圖
顯示了當 =MAX_BOARD= 為7時，1D指標和2D指標的對應關係。

#+BEGIN_EXAMPLE
  j  -1   0   1   2   3   4   5   6
i +----------------------------------
-1|   0   1   2   3   4   5   6   7
 0|   8   9  10  11  12  13  14  15
 1|  16  17  18  19  20  21  22  23
 2|  24  25  26  27  28  29  30  31
 3|  32  33  34  35  36  37  38  39
 4|  40  41  42  43  44  45  46  47
 5|  48  49  50  51  52  53  54  55
 6|  56  57  58  59  60  61  62  63
 7|  64  65  66  67  68  69  70  71  72
#+END_EXAMPLE

宏 =POS, I, J= 用於在 1D 索引 =pos= 和 2D 索引 =(i,j)= 之間轉換，定義如下：

#+BEGIN_EXAMPLE
#define POS(i, j)    ((MAX_BOARD + 2) + (i) * (MAX_BOARD + 1) + (j))
#define I(pos)       ((pos) / (MAX_BOARD + 1) - 1)
#define J(pos)       ((pos) % (MAX_BOARD + 1) - 1)
#+END_EXAMPLE

所有棋盤外的點的 1D 指標被標記為 =GRAY= 。因此如果 =board_size= 和 =MAX_BOARD=
都是 7， 則看似如下：

#+BEGIN_EXAMPLE
  j  -1   0   1   2   3   4   5   6
i +----------------------------------
-1|   #   #   #   #   #   #   #   #
 0|   #   .   .   .   .   .   .   .
 1|   #   .   .   .   .   .   .   .
 2|   #   .   .   .   .   .   .   .
 3|   #   .   .   .   .   .   .   .
 4|   #   .   .   .   .   .   .   .
 5|   #   .   .   .   .   .   .   .
 6|   #   .   .   .   .   .   .   .
 7|   #   #   #   #   #   #   #   #   #
#+END_EXAMPLE

標記為 ='#'= 的索引值為 =GRAY= 。如果 =MAX_BOARD= 為7 而 =board_size= 為 5：

#+BEGIN_EXAMPLE
  j  -1   0   1   2   3   4   5   6
i +----------------------------------
-1|   #   #   #   #   #   #   #   #
 0|   #   .   .   .   .   .   #   #
 1|   #   .   .   .   .   .   #   #
 2|   #   .   .   .   .   .   #   #
 3|   #   .   .   .   .   .   #   #
 4|   #   .   .   .   .   .   #   #
 5|   #   #   #   #   #   #   #   #
 6|   #   #   #   #   #   #   #   #
 7|   #   #   #   #   #   #   #   #   #
#+END_EXAMPLE

棋盤上的導航是由 =SOUTH, WEST, NORTH, EAST= 宏完成的，

#+BEGIN_SRC c
#define NS           (MAX_BOARD + 1)
#define WE           1
#define SOUTH(pos)   ((pos) + NS)
#define WEST(pos)    ((pos) - 1)
#define NORTH(pos)   ((pos) - NS)
#define EAST(pos)    ((pos) + 1)
#+END_SRC

也有 =SW, NW, NE, SE, SS, WW, NN, EE= 等速記宏用於兩步移動的縮寫。

任何從棋盤上一點到相鄰或對角點的移動都保證會在棋盤陣列中產生一個有效索引，如果它
不在棋盤上，則找到的顏色是 GRAY。這裡有兩個宏用於對是否在棋盤外進行顯式測試：

#+BEGIN_SRC c
#define ON_BOARD(pos) (board[pos] != GRAY)
#define ON_BOARD1(pos) (((unsigned) (pos) < BOARDSIZE) && board[pos] != GRAY)
#+END_SRC

第一個用于算法，第二個用於斷言測試。

使用一維數組表示棋盤的優點是具有顯著的性能優勢。我們只需要一個變量去確定棋盤位置，
意味著很多函數需要更少的參數。而且，通常一維坐標只要計算一次，而二維坐標需要計算
兩次：例如，如果我們想要 =pos= 的右上角坐標，我們可以用 =NORTH(EAST(pos))= 代替
=(i+1, j-1)= 。

*重要* ：二維坐標 =(-1,-1)= ，用於放棄一步（pass）或者有時用於指向不存在的點（no
point），映射到一維坐標是 =0= ，而不是 =-1= 。使用宏 =NO_MOVE= 或 =PASS_MODE= 來
代替普通的 =0= 。

在多個方向上循環可以直接寫為：

#+BEGIN_SRC c
  for (k = 0; k < 4; k++) {
      int d = delta[k];
      do_something(pos + d);
  }
#+END_SRC

下面的常量對於遍歷整個棋盤和對數組與棋盤進行1對1映射非常有用：

#+BEGIN_SRC c
#define BOARDSIZE    ((MAX_BOARD + 2) * (MAX_BOARD + 1) + 1)
#define BOARDMIN     (MAX_BOARD + 2)
#define BOARDMAX     (MAX_BOARD + 1) * (MAX_BOARD + 1)
#+END_SRC

=BOARDSIZE= 是一維棋盤數組的實際大小， =BOARDMIN= 是棋盤上第一個點對應的坐標索引，
而 =BOARDMAX= 是棋盤上最後一個點對應的坐標索引加上1。

通常我們想要遍歷棋盤，在每個頂點上執行一些函數，這裡有兩種可能的方法：

#+BEGIN_SRC c
  int m, n;
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      do_something(POS(m, n));
    }
#+END_SRC

或者

#+BEGIN_SRC c
  int pos;
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (ON_BOARD(pos))
      do_something(pos);
  }
#+END_SRC

** 增量棋盤數據結構
除了全局棋盤狀態， ='board.c'= 中的算法實現了增量更新方法，跟蹤每個棋子串的以下
信息：

- 棋子串的顏色（黑、白、灰）。
- 棋子串中棋子的個數。
- 棋子串的起點，即標準參考點，定義為串中具有最小一維棋盤坐標的點。
- 串中棋子的列表。
- 氣的數量。
- 氣的列表，如果有太多的氣，列表會被截斷。
- 鄰近棋子串的個數。
- 鄰近棋子串的列表。

基本數據結構是：

#+BEGIN_SRC c
struct string_data {
  int color;                       /* Color of string, BLACK or WHITE */
  int size;                        /* Number of stones in string. */
  int origin;                      /* Coordinates of "origin", i.e. */
                                   /* "upper left" stone. */
  int liberties;                   /* Number of liberties. */
  int libs[MAX_LIBERTIES];         /* Coordinates of liberties. */
  int neighbors;                   /* Number of neighbor strings */
  int neighborlist[MAXCHAIN];      /* List of neighbor string numbers. */
  int mark;                        /* General purpose mark. */
};

struct string_data string[MAX_STRINGS];
#+END_SRC

應該清楚的是，幾乎所有的信息都存儲在 =string= 數組中。要獲得棋盤坐標到 =string=
數組的轉換，我們有

#+BEGIN_SRC c
static int string_number[BOARDMAX];
#+END_SRC

包含 =string= 數組中的索引。此信息僅在非空頂點有效，因此必須先驗證 $board[pos]
!= EMPTY$ 。

=string_data= 結構並不包含棋子坐標的數組，相關信息儲存在一個單獨的數組中：

#+BEGIN_SRC c
static int next_stone[BOARDMAX];
#+END_SRC

這個數組實現了棋子的循環鏈錶。每一個頂點包含了指向另一個頂點（可能是相同的）的指
針。從棋盤上任一棋子開始，在返回到起點之前，沿著這些指針應該以任意順序遍歷整個棋
子串。至於 ='string_number'= 數組，該信息在棋盤的空點上無效。這個數據結構的好處
在於只需要固定的空間（無關棋子串的數目），並且可以很容易地添加新的棋子或合併兩個
棋子串。

此外，代碼使用了一些靜態變量：

#+BEGIN_SRC c
static int ml[BOARDMAX];
static int liberty_mark;
static int string_mark;
static int next_string;
static int strings_initialized = 0;
#+END_SRC

=ml= 數組和 =liberty_mark= 用於“標記”棋盤上的氣，如避免將相同的氣計算兩遍。約
定如果 =ml[pos]= 和 =liberty_mark= 具有相同的值，則 =pos= 將被標記。要清除所有標
記，只要增加 =liberty_mark= 的值，因為它永遠不允許被減少。

=string_data= 結構體的 =mark= 字段與 =string_mark= 之間存在相同的關係。當然，這
些是用來標記單個的棋子串。

=next_string= 給出了 =string= 數組中下一個可用條目的數量。然後當所有的數據結構都
一直為最新的時候，將 =string_initialized= 設置為1。可用通過調用
=incremental_board_init()= 在 ='board'= 數組指定任意棋盤位置。並不需要顯式地調用
這個函數，因為其他任何需要此信息的函數都會在完成前調用它。

代碼中有趣的部分是當棋子落下並在隨後撤銷時，數據結構的增量更新。要了解添加棋子所
涉及的策略，首先必須知道撤銷移動是如何工作的。其思想是，一旦某個信息即將被更改，
舊值將被壓入堆棧，該堆棧會存儲值及其地址。堆棧由以下結構構建：

#+BEGIN_SRC c
struct change_stack_entry {
  int *address;
  int value;
};

struct change_stack_entry change_stack[STACK_SIZE];
int change_stack_index;
#+END_SRC

并使用宏進行操作：

#+BEGIN_SRC c
BEGIN_CHANGE_RECORD()
PUSH_VALUE(v)
POP_MOVE()
#+END_SRC

調用 =BEGIN_CHANGE_RECORD()= 在 =address= 字段存儲一個空指針，用於指示新移動的更
改開始。正如前述 =PUSH_VALUE()= 存儲一個值和其對應的地址。假設所有更改的信息都被
適當地推送到堆棧中，取消移動操作只需要調用 =POP_MOVE()= ，它只是以相反的順序將值
分配給地址，直到到達空指針。此描述略有簡化，因為堆棧只能存儲 ='int'= 值，我們還
需要存儲對棋盤的更改。因此我們有兩個並行堆棧，其中一個存儲 int 值，另一個存儲
=Intersection= 值。

當一顆棋子落于盤上，如果對方的棋子可以被提走，將首先被刪除，在此步驟中，我們必須
為被刪除的棋子而將棋盤值和 =next_stone= 指針推入堆棧中，並且為被刪除的棋子串更新
氣和鄰居列表。但是，我們沒有必要推送所有被刪除棋子的 ='string'= 條目。由於我們不
重複使用這些條目，因此它們將保持完整，直到走子被推入，它們又被重新使用。

在此之後，我們放下了新的棋子并獲得了三個不同的情況：

1. 新落子是孤立的，也就是說它沒有友鄰。
2. 新落子只有一個友鄰。
3. 新落子至少有兩個友鄰。

第一種情況是最簡單的，我們通過使用 =next_string= 給出的值創建一個新串，并增加這
個值。新串的大小為1， =next_stone= 指針指向自身，通過尋找四個方向的空點可以找到
氣，可能的鄰接串以相同的方式被找到，那些串需要刪除一口氣并添加一個鄰居。

第二種情況我們不需要創建一個新串，但是要將新的棋子擴展到鄰居串上。這涉及到將新的
棋子鏈接到循環鏈錶中，如果需要移動原點，并更新氣和鄰居。也需要為新落子的鄰居更新
其氣和鄰居信息

最後是第三者情況，我們需要合併已經存在的鄰居。為了不必存儲過多的信息，我們為新落
子創建一個新串，讓它吸收鄰居棋子串。因此，關於這些的所有信息都可以簡單地留在
'string' 數組中，就像刪除的棋子串那樣。在這裡，跟蹤氣和鄰居變得有點複雜，因為它
們可能被多個已合併的棋子串共享。無論如何，通過充分利用標記，一切都變得相當簡單。

經常使用的結構：

#+BEGIN_SRC c
    pos = FIRST_STONE(s);
    do {
        ...
        pos = NEXT_STONE(pos);
    } while (!BACK_TO_FIRST_STONE(s, pos));
#+END_SRC

用數字 ='s'= 遍歷棋子串一次，通過 =pos= 保存坐標。通常 =pos= 作為棋盤坐標，
='s'= 作為 =string= 數組的索引，有時也作為指向 =string= 數組條目的指針。

** 某些棋盤函數
*解讀* ，在計算機博弈論中也經常稱之為 *搜索* ，是 GNU Go 中的一個基本過程。



<<territory>>
<<escape>>
<<surround>>
<<owl>>
<<return_code>>
<<colored_display>>
<<the_board_state_struct>>
<<hasing_of_positions>>
<<incremental_board_data_structures>>
